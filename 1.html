<!doctype html>
<html lang="en">

<head>
  
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.2.1/css/bootstrap.min.css"
    integrity="sha384-GJzZqFGwb1QTTN6wy59ffF1BuGJpLSa9DkKMp0DgiMDm4iYMj70gZWKYbI706tWS" crossorigin="anonymous">

  
  <link rel="stylesheet" href="main.css">

  
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css"
    integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous">

  
  <link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Ubuntu:regular,bold&subset=Latin"> 

   <!-- Import element definition -->
   <script type="module" src="https://cdn.jsdelivr.net/gh/zerodevx/zero-md@2/dist/zero-md.min.js"></script>

  <title>Erodotos Demetriou</title>
</head>

<body>

  
  <section>
    <div class="container header">
      <div class="row" style="padding-top: 50px;">
        <div class="col-8 my-auto">
          <h1>Erodotos Demetriou</h1>
        </div>
        <div class="nav-link col-1 my-auto text-center">
          <a href="./index.html">POSTS</a>
        </div>
        <div class="nav-link col-1 my-auto text-center">
          <a href="./assets/Erodotos Demetriou CV.pdf" target="_blank">CV</a>
        </div>
        <div class="nav-link col-1 my-auto text-center">
          <a href="https://github.com/Erodotos" target="_blank">GITHUB</a>
        </div>
        <div class="nav-link col-1 my-auto text-center">
          <a href="https://twitter.com/erodotosd" target="_blank">TWITTER</a>
        </div>
      </div>
    </div>
  </section>
  
  <zero-md src="https://github.com/zupzup/blog/blob/main/epoll-with-rust/post.md"></zero-md>

  <!-- <section class="content">
    <div class="container mt-5">
        <div>
            Post1
        </div>
        <div>
            <p>In a <a href="https://zupzup.org/go-ast-traversal/">previous post</a>, I showed a basic example of how to traverse an AST with Go. The ability to traverse and analyse the AST of a program is useful for building code-analysis tools and such, but the real fun starts when we manipulate the Abstract Syntax Tree of a program, which enables us to build powerful developer tools.</p>

<p>In this post, we will create a simple tool that does something useful in regards to documentation. The tool will parse a given Go source file and, for every <strong>exported</strong> function without a <strong>Doc string</strong>, it will spit out a warning and create a <code>// TODO: document exported function</code>-placeholder comment where the Doc-string should be.</p>

<p>While this very simple tool probably won&rsquo;t change the world, it&rsquo;s small enough to showcase the general concept of how to parse to an AST, manipulate it and then write the changed code back out.</p>

<p>Let&rsquo;s get started.</p>

<h2>Code Example</h2>

<p>First, let&rsquo;s look at our source file called <code>test.go</code>:</p>

<pre><code class="language-go">func main() {
    fmt.Println(&quot;testprogram&quot;)
    DoStuff()
}

func unexportedFunction() {}

// Whatever does other stuff
func Whatever() {}

func AnExportedFunction() {}

func DoStuff() {}

// DoOtherStuff does other stuff
func DoOtherStuff() {}
</code></pre>

<p>Our first step is to parse this <code>test.go</code> file into an AST:</p>

<pre><code class="language-go">// parse file
fset := token.NewFileSet()
node, err := parser.ParseFile(fset, &quot;test.go&quot;, nil, parser.ParseComments)
if err != nil {
    log.Fatal(err)
}
</code></pre>

<p>Our strategy is to identify all exported functions without a Doc-string and add the <code>TODO</code> comment on top of them.
For this purpose, we also need to identify and collect all comments in the AST, to be able to position the new comments correctly in the file&rsquo;s <code>Comments</code> list.</p>

<p>To traverse the AST, we use the <code>ast.Inspect</code> function:</p>

<pre><code class="language-go">comments := []*ast.CommentGroup{}
ast.Inspect(node, func(n ast.Node) bool {
    // collect comments
    c, ok := n.(*ast.CommentGroup)
    if ok {
        comments = append(comments, c)
    }
    // handle function declarations without documentation
    fn, ok := n.(*ast.FuncDecl)
    if ok {
        if fn.Name.IsExported() &amp;&amp; fn.Doc.Text() == &quot;&quot; {
            // print warning
            fmt.Printf(&quot;exported function declaration without documentation
                found on line %d: \n\t%s\n&quot;, fset.Position(fn.Pos()).Line, fn.Name.Name)
        }
    }
})
</code></pre>

<p>First, we identify and collect all <code>ast.CommentGroup</code> nodes, which are the existing comments in the code.
We also identify <code>ast.FuncDecl</code> nodes, which are function declarations and, if they are exported and their <code>fn.Doc.Text()</code> - the Doc string - is empty, we print a warning with the position and name of the undocumented function.</p>

<p>After identifying our targets, we need to manipulate them by including our <code>TODO</code>-comment into their Doc-string. We do this by creating a new <code>ast.Comment</code> and <code>ast.CommentGroup</code> and set <code>fn.Doc</code> to that comment group:</p>

<pre><code class="language-go">// create todo-comment
comment := &amp;ast.Comment{
    Text:  &quot;// TODO: document exported function&quot;,
    Slash: fn.Pos() - 1,
}
// create CommentGroup and set it to the function's documentation comment
cg := &amp;ast.CommentGroup{
    List: []*ast.Comment{comment},
}
fn.Doc = cg
</code></pre>

<p>What&rsquo;s important here is, that we need to set the <code>Slash</code> property of the newly created <code>ast.Comment</code> node to <code>fn.Pos() - 1</code>, to properly position the comment. This is the identified function&rsquo;s position in the file, expressed as its offset and we reduce it by 1 to get to the line just above the function.</p>

<p>After that&rsquo;s done, we set the <code>node</code>&rsquo;s <code>Comments</code> to our collected <code>CommentGroup</code> list, so they are rendered and write the AST, pretty-printed with the <code>go/printer</code> package, to a file called <code>new.go</code>:</p>

<pre><code class="language-go">// set ast's comments to the collected comments
node.Comments = comments
// write changed AST to file
f, err := os.Create(&quot;new.go&quot;)
defer f.Close()
if err := printer.Fprint(f, fset, node); err != nil {
    log.Fatal(err)
}
</code></pre>

<p>The result in <code>new.go</code> looks like this, just like we planned:</p>

<pre><code class="language-go">func main() {
    fmt.Println(&quot;testprogram&quot;)
    DoStuff()
}

func unexportedFunction() {}

// Whatever does other stuff
func Whatever() {}

// TODO: document exported function
func AnExportedFunction() {}

// TODO: document exported function
func DoStuff() {}

// DoOtherStuff does other stuff
func DoOtherStuff() {}
</code></pre>

<p>That&rsquo;s it. :)</p>

<p>The full example code can be found <a href="https://github.com/zupzup/ast-manipulation-example">here</a></p>

<h2>Conclusion</h2>

<p>Due to the complexity of Software Engineering, good developer tools are essential for high developer efficiency. Although Go already has a great ecosystem of powerful tools, the ability to build your own tools opens some interesting possibilities, especially when it comes to tools tailored explicitly to your own unique needs.</p>

<p>Go provides good, well documented libraries in the standard library to write such custom-tailored tools. Additionally, the knowledge and skills necessary to build such tools, in my opinion, also improve one&rsquo;s understanding of the language itself.</p>

<p>Another benefit of writing your own tools is that it&rsquo;s just a great feeling to use your own, hand-crafted tool to boost your development flow. :)</p>

<h4>Resources</h4>

<ul>
<li><a href="https://zupzup.org/go-ast-traversal/">AST-Traversal in Go</a></li>
<li><a href="https://github.com/zupzup/ast-manipulation-example">Code Example</a></li>
<li><a href="https://golang.org/pkg/go/token/">Go token package</a></li>
<li><a href="https://golang.org/pkg/go/parser/">Go parser package</a></li>
<li><a href="https://golang.org/pkg/go/ast/">Go ast package</a></li>
<li><a href="https://golang.org/pkg/go/printer/">Go printer package</a></li>
</ul>

        </div>
        
    </div>
  </section> -->

  
  <section>
    <div class="footer row text-center">
      <div class="col-4"></div>
      <div class="col-4 my-auto"><p>Website developed by <a href="./index.html">Erodotos Demetriou</a> | Last Update 2021</p></div>
      <div class="col-4"></div>
    </div>
  </section>
    



  
  
  <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js"
    integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo"
    crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.6/umd/popper.min.js"
    integrity="sha384-wHAiFfRlMFy6i5SRaxvfOCifBUQy1xHdJ/yoi7FRNXMRBu5WHdZYu1hA6ZOblgut"
    crossorigin="anonymous"></script>
  <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.2.1/js/bootstrap.min.js"
    integrity="sha384-B0UglyR+jN6CkvvICOB2joaf5I4l3gm9GU6Hc1og6Ls7i6U/mkkaduKaBhlAXv9k"
    crossorigin="anonymous"></script>
  <script>
    $(document).ready(function () {
      $('[data-toggle="popover"]').popover({ html: true });
    });
  </script>
</body>

</html>